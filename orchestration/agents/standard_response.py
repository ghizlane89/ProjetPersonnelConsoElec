#!/usr/bin/env python3
"""
üìä STANDARD RESPONSE CONTRACT
============================

Contrat de donn√©es uniforme pour tous les agents.
√âlimine les probl√®mes de formats incoh√©rents.
"""

from typing import Dict, Any, Optional, Union
from dataclasses import dataclass
from enum import Enum
import logging

class ResponseStatus(Enum):
    SUCCESS = "success"
    ERROR = "error"
    WARNING = "warning"

class ResponseType(Enum):
    CONSUMPTION = "consumption"
    COST = "cost"
    ZONES = "zones"
    MOYENNE = "moyenne"
    FORECAST = "forecast"

@dataclass
class StandardResponse:
    """Format uniforme pour toutes les r√©ponses d'agents"""
    
    # Donn√©es principales
    value: float
    unit: str
    status: ResponseStatus
    response_type: ResponseType
    
    # Contexte
    question: str
    period: str
    aggregation: str
    
    # M√©tadonn√©es
    metadata: Dict[str, Any]
    
    # R√©ponse format√©e
    answer: str
    
    # Source et tra√ßabilit√©
    source: str
    agent_chain: list
    
    def __post_init__(self):
        """Validation apr√®s initialisation"""
        if self.value < 0:
            logging.warning(f"Valeur n√©gative d√©tect√©e: {self.value}")
        
        if not self.answer:
            self.answer = self._generate_default_answer()
    
    def _generate_default_answer(self) -> str:
        """G√©n√®re une r√©ponse par d√©faut si manquante"""
        if self.response_type == ResponseType.MOYENNE:
            return f"üìä Votre consommation moyenne est de {self.value:.1f} {self.unit}."
        elif self.response_type == ResponseType.COST:
            return f"üí∞ Le co√ªt est de {self.value:.2f} {self.unit}."
        elif self.response_type == ResponseType.ZONES:
            return f"üè† Analyse des zones: {self.value:.1f} {self.unit}."
        else:
            return f"‚ö° R√©sultat: {self.value:.1f} {self.unit}."
    
    def to_dict(self) -> Dict[str, Any]:
        """Conversion en dictionnaire pour compatibilit√©"""
        return {
            'question': self.question,
            'answer': self.answer,
            'value': self.value,
            'unit': self.unit,
            'period': self.period,
            'status': self.status.value,
            'type': self.response_type.value,
            'source': self.source,
            'metadata': self.metadata,
            'agent_chain': self.agent_chain
        }
    
    @classmethod
    def from_mcp_result(cls, question: str, mcp_result: Dict[str, Any], response_type: ResponseType) -> 'StandardResponse':
        """Cr√©e une StandardResponse √† partir d'un r√©sultat MCP"""
        
        # Extraction intelligente de la valeur (r√©sout le probl√®me de formatage)
        value = cls._extract_value(mcp_result)
        
        # Extraction des m√©tadonn√©es
        data = mcp_result.get('data', {})
        period = data.get('period', 'unknown')
        aggregation = data.get('aggregation', 'unknown')
        
        # D√©termination de l'unit√©
        unit = cls._determine_unit(response_type, data)
        
        return cls(
            value=value,
            unit=unit,
            status=ResponseStatus.SUCCESS if mcp_result.get('status') == 'success' else ResponseStatus.ERROR,
            response_type=response_type,
            question=question,
            period=period,
            aggregation=aggregation,
            metadata=data,
            answer="",  # Sera g√©n√©r√© automatiquement
            source=mcp_result.get('source', 'mcp'),
            agent_chain=['mcp']
        )
    
    @staticmethod
    def _extract_value(mcp_result: Dict[str, Any]) -> float:
        """üîß Extraction intelligente de la valeur (corrige les erreurs DataFrame)"""
        data = mcp_result.get('data', {})
        
        # üö® PRIORIT√â: V√©rifier les erreurs DataFrame
        if 'error' in data:
            error_msg = data['error']
            logging.error(f"Erreur MCP d√©tect√©e: {error_msg}")
            # Ne pas retourner de valeur fallback hardcod√©e, laisser le workflow g√©rer l'erreur
            return 0.0
        
        # Format 1: data.value directe
        if 'value' in data:
            try:
                return float(data['value'])
            except (ValueError, TypeError):
                pass
        
        # Format 2: data.summary.total
        if 'summary' in data and 'total' in data['summary']:
            try:
                return float(data['summary']['total'])
            except (ValueError, TypeError):
                pass
        
        # Format 3: data.data.summary.total (format complexe)
        if 'data' in data and isinstance(data['data'], dict):
            nested_data = data['data']
            if 'summary' in nested_data and 'total' in nested_data['summary']:
                try:
                    return float(nested_data['summary']['total'])
                except (ValueError, TypeError):
                    pass
            if 'value' in nested_data:
                try:
                    return float(nested_data['value'])
                except (ValueError, TypeError):
                    pass
        
        # Format 4: Directement dans le r√©sultat
        if 'value' in mcp_result:
            try:
                return float(mcp_result['value'])
            except (ValueError, TypeError):
                pass
        
        # Format 5: Zones (cas sp√©cial)
        if 'zones' in data:
            zones = data['zones']
            if isinstance(zones, dict):
                try:
                    return sum(float(v) for v in zones.values() if isinstance(v, (int, float)))
                except (ValueError, TypeError):
                    pass
        
        # Format 6: Comparaisons temporelles
        if 'current_period' in data:
            try:
                return float(data['current_period'])
            except (ValueError, TypeError):
                pass
        
        # Fallback avec valeur r√©aliste
        logging.warning(f"Impossible d'extraire la valeur de: {mcp_result}")
        return 0.0
    
    @staticmethod
    def _determine_unit(response_type: ResponseType, data: Dict[str, Any]) -> str:
        """D√©termine l'unit√© appropri√©e"""
        if response_type == ResponseType.COST:
            return "‚Ç¨"
        elif response_type == ResponseType.MOYENNE:
            granularity = data.get('granularity', 'day')
            if granularity == 'day':
                return "kWh/jour"
            elif granularity == 'week':
                return "kWh/semaine"
            else:
                return "kWh"
        else:
            return "kWh"

class ResponseBuilder:
    """Constructeur de r√©ponses standardis√©es"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def _add_warmth_and_empathy(self, base_response: str, question: str) -> str:
        """üåü Ajoute de l'empathie et de la chaleur √† la r√©ponse"""
        
        # üéØ Phrases d'empathie et de chaleur
        warm_prefixes = [
            "üåü Excellente question ! ",
            "üí° Tr√®s bonne question ! ",
            "üéØ Bonne question ! ",
            "‚ú® Int√©ressante question ! ",
            "üëè Belle question ! ",
            "üí™ Question pertinente ! ",
            "üéâ Question int√©ressante ! ",
            "‚≠ê Question utile ! ",
            "üî• Question importante ! ",
            "üíé Question bien formul√©e ! "
        ]
        
        # üéØ Phrases de conclusion chaleureuses
        warm_suffixes = [
            " C'est une information tr√®s utile pour suivre votre consommation !",
            " Cela vous donne une bonne id√©e de vos habitudes √©nerg√©tiques !",
            " C'est parfait pour optimiser votre consommation !",
            " Vous avez maintenant une vision claire de votre usage !",
            " C'est tr√®s utile pour votre suivi √©nerg√©tique !",
            " Cela vous aide √† mieux comprendre votre consommation !",
            " C'est excellent pour votre gestion √©nerg√©tique !",
            " Vous avez maintenant toutes les informations n√©cessaires !",
            " C'est tr√®s utile pour votre optimisation √©nerg√©tique !",
            " Cela vous donne une belle perspective de votre consommation !"
        ]
        
        # üéØ Phrases d'encouragement pour les moyennes
        encouragement_suffixes = [
            " Continuez √† surveiller vos habitudes !",
            " C'est un bon indicateur de votre consommation !",
            " Cela vous aide √† optimiser votre usage !",
            " C'est parfait pour votre suivi quotidien !",
            " Vous avez une belle ma√Ætrise de votre consommation !",
            " C'est excellent pour votre gestion √©nerg√©tique !",
            " Cela vous donne une vision claire de vos habitudes !",
            " C'est tr√®s utile pour votre optimisation !",
            " Vous avez maintenant un bon rep√®re !",
            " C'est parfait pour votre suivi √©nerg√©tique !"
        ]
        
        import random
        
        # üéØ Choisir un pr√©fixe chaleureux
        prefix = random.choice(warm_prefixes)
        
        # üéØ Choisir un suffixe selon le type de r√©ponse
        question_lower = question.lower()
        if any(word in question_lower for word in ['moyenne', 'moyen', 'par jour', 'par heure', 'quotidien']):
            suffix = random.choice(encouragement_suffixes)
        else:
            suffix = random.choice(warm_suffixes)
        
        # üéØ Construire la r√©ponse chaleureuse
        warm_response = f"{prefix}{base_response}{suffix}"
        
        return warm_response
    
    def build_consumption_response(self, question: str, mcp_result: Dict[str, Any], semantic_validation: Dict[str, Any] = None) -> StandardResponse:
        """üîß Construit une r√©ponse de consommation intelligente (corrige l'incoh√©rence temporelle)"""
        response = StandardResponse.from_mcp_result(question, mcp_result, ResponseType.CONSUMPTION)
        
        # üÜï PRIORIT√â: Utiliser la validation s√©mantique si disponible
        if semantic_validation and semantic_validation.get('validated_period'):
            validated_period = semantic_validation['validated_period']
            period_mapping = {
                'current_month': 'ce mois-ci',
                'last_month': 'le mois dernier', 
                'current_year': 'cette ann√©e',
                'last_year': 'l\'ann√©e derni√®re',
                'current_week': 'cette semaine',
                '30d': 'ces 30 derniers jours',
                '7d': 'ces 7 derniers jours',
                '1d': 'hier',
                '1d_avant_hier': 'avant-hier'  # üîß CORRECTION : Ajouter avant-hier
            }
            period_text = period_mapping.get(validated_period, f'sur la p√©riode demand√©e')
        else:
            # Fallback: formatage intelligent bas√© sur la QUESTION
            question_lower = question.lower()
            
            # D√©tection intelligente de la p√©riode demand√©e dans la question
            if 'hier' in question_lower:
                period_text = 'hier'
            elif 'avant-hier' in question_lower or 'avant hier' in question_lower:
                period_text = 'avant-hier'  # üîß CORRECTION : Ajouter avant-hier
            elif 'ce mois' in question_lower or 'mois-ci' in question_lower:
                period_text = 'ce mois-ci'
            elif 'mois dernier' in question_lower or 'dernier mois' in question_lower:
                period_text = 'le mois dernier'
            elif 'cette semaine' in question_lower or 'semaine-ci' in question_lower:
                period_text = 'cette semaine'
            elif 'semaine derni√®re' in question_lower or 'derni√®re semaine' in question_lower:
                period_text = 'la semaine derni√®re'
            elif 'semaine pass√©e' in question_lower or 'semaine √©coul√©e' in question_lower:
                period_text = 'la semaine pass√©e'
            elif 'semaine' in question_lower and 'derni√®re' in question_lower:
                period_text = 'la semaine derni√®re'  # üîß CORRECTION : Capturer "semaine derni√®re"
            elif 'consommation' in question_lower and 'semaine' in question_lower and 'derni√®re' in question_lower:
                period_text = 'la semaine derni√®re'  # üîß CORRECTION : Capturer "consommation semaine derni√®re"
            elif 'cette ann√©e' in question_lower or 'ann√©e-ci' in question_lower:
                period_text = 'cette ann√©e'
            elif 'par jour' in question_lower:
                period_text = 'par jour'
            elif 'par semaine' in question_lower:
                period_text = 'par semaine'
            elif 'par mois' in question_lower:
                period_text = 'par mois'
            elif 'par ann√©e' in question_lower or 'par an' in question_lower:
                period_text = 'par ann√©e'
            else:
                # Fallback sur le mapping technique si pas de correspondance
                period_text = {
                    '1d': 'hier',
                    '7d': 'cette semaine',
                    '30d': 'ces 30 derniers jours',
                    '365d': 'cette ann√©e'
                }.get(response.period, f'sur la p√©riode demand√©e')
        
        response.answer = f"‚ö° Vous avez consomm√© {response.value:.1f} kWh {period_text}."
        # üåü Ajouter de l'empathie et de la chaleur
        response.answer = self._add_warmth_and_empathy(response.answer, question)
        return response
    
    def build_moyenne_response(self, question: str, mcp_result: Dict[str, Any]) -> StandardResponse:
        """Construit une r√©ponse de moyenne intelligente"""
        response = StandardResponse.from_mcp_result(question, mcp_result, ResponseType.MOYENNE)
        
        # Formatage intelligent bas√© sur la question ET les m√©tadonn√©es
        question_lower = question.lower()
        granularity = response.metadata.get('granularity', 'day')
        
        # üîß D√©tecter la p√©riode sp√©cifique dans la question
        period_context = ""
        if 'mois dernier' in question_lower:
            period_context = " le mois dernier"
        elif 'semaine derni√®re' in question_lower:
            period_context = " la semaine derni√®re"
        elif 'ann√©e derni√®re' in question_lower:
            period_context = " l'ann√©e derni√®re"
        
        # PRIORIT√â: D√©tecter la granularit√© dans la question d'abord
        if 'par an' in question_lower or 'par ann√©e' in question_lower or 'annuelle' in question_lower:
            response.answer = f"üìä Votre consommation moyenne par an{period_context} est de {response.value:.0f} kWh/an."
        elif 'par mois' in question_lower or 'mensuelle' in question_lower:
            response.answer = f"üìà Votre consommation moyenne par mois{period_context} est de {response.value:.1f} kWh/mois."
        elif 'par semaine' in question_lower or 'hebdomadaire' in question_lower:
            response.answer = f"üìä Votre consommation moyenne par semaine{period_context} est de {response.value:.1f} kWh/semaine."
        elif 'par jour' in question_lower or 'quotidienne' in question_lower or 'journali√®re' in question_lower:
            response.answer = f"üìÖ Votre consommation moyenne par jour{period_context} est de {response.value:.1f} kWh/jour."
        elif 'par heure' in question_lower or 'horaire' in question_lower:
            response.answer = f"‚è∞ Votre consommation moyenne par heure{period_context} est de {response.value:.2f} kWh/h."
        # Fallback sur les m√©tadonn√©es si pas trouv√© dans la question
        elif granularity in ['ann√©e', 'year']:
            response.answer = f"üìä Votre consommation moyenne par an est de {response.value:.0f} kWh/an."
        elif granularity in ['mois', 'month']:
            response.answer = f"üìà Votre consommation moyenne par mois est de {response.value:.1f} kWh/mois."
        elif granularity in ['semaine', 'week']:
            response.answer = f"üìä Votre consommation moyenne par semaine est de {response.value:.1f} kWh/semaine."
        elif granularity in ['jour', 'day']:
            response.answer = f"üìÖ Votre consommation moyenne par jour est de {response.value:.1f} kWh/jour."
        elif granularity in ['heure', 'hour']:
            response.answer = f"‚è∞ Votre consommation moyenne par heure est de {response.value:.2f} kWh/h."
        else:
            response.answer = f"üìä Votre consommation moyenne est de {response.value:.1f} {response.unit}."
        
        # üåü Ajouter de l'empathie et de la chaleur
        response.answer = self._add_warmth_and_empathy(response.answer, question)
        return response
    
    def build_cost_response(self, question: str, mcp_result: Dict[str, Any]) -> StandardResponse:
        """Construit une r√©ponse de co√ªt"""
        response = StandardResponse.from_mcp_result(question, mcp_result, ResponseType.COST)
        
        data = response.metadata
        consumption = data.get('consumption_kwh', 0)
        advice = data.get('advice')
        
        if advice:
            response.answer = f"üí° {advice}. Co√ªt actuel: {response.value:.2f}‚Ç¨ pour {consumption:.1f} kWh."
        else:
            response.answer = f"üí∞ Le co√ªt est de {response.value:.2f}‚Ç¨ pour une consommation de {consumption:.1f} kWh."
        
        # üåü Ajouter de l'empathie et de la chaleur
        response.answer = self._add_warmth_and_empathy(response.answer, question)
        return response
    
    def build_zones_response(self, question: str, mcp_result: Dict[str, Any]) -> StandardResponse:
        """Construit une r√©ponse de comparaison de zones"""
        response = StandardResponse.from_mcp_result(question, mcp_result, ResponseType.ZONES)
        
        data = response.metadata
        zones = data.get('zones', {})
        
        if zones:
            max_zone = max(zones.items(), key=lambda x: x[1])
            zone_name, zone_value = max_zone
            
            zone_names = {
                'cuisine': 'la cuisine',
                'buanderie': 'la buanderie', 
                'chauffage': 'le chauffage'
            }
            
            response.answer = f"üè† {zone_names.get(zone_name, zone_name)} consomme le plus avec {zone_value:.1f} kWh. Total: {response.value:.1f} kWh."
        else:
            response.answer = "Aucune donn√©e de zones disponible."
        
        # üåü Ajouter de l'empathie et de la chaleur
        response.answer = self._add_warmth_and_empathy(response.answer, question)
        return response
    
    def build_temporal_response(self, question: str, mcp_result: Dict[str, Any], semantic_validation: Dict[str, Any] = None) -> StandardResponse:
        """üÜï Construit une r√©ponse temporelle sp√©cifique"""
        response = StandardResponse.from_mcp_result(question, mcp_result, ResponseType.CONSUMPTION)
        
        # üÜï PRIORIT√â: Utiliser la validation s√©mantique pour le formatage
        if semantic_validation and semantic_validation.get('validated_period'):
            validated_period = semantic_validation['validated_period']
            
            if validated_period == 'current_month':
                response.answer = f"üìÖ Vous avez consomm√© {response.value:.1f} kWh ce mois-ci."
            elif validated_period == 'last_month':
                response.answer = f"üìÖ Vous avez consomm√© {response.value:.1f} kWh le mois dernier."
            elif validated_period == 'current_year':
                response.answer = f"üìÖ Vous avez consomm√© {response.value:.1f} kWh cette ann√©e."
            elif validated_period == 'last_year':
                response.answer = f"üìÖ Vous avez consomm√© {response.value:.1f} kWh l'ann√©e derni√®re."
            elif validated_period == '1d':
                response.answer = f"‚ö° Vous avez consomm√© {response.value:.1f} kWh hier."
            elif validated_period == '1d_avant_hier':
                response.answer = f"‚ö° Vous avez consomm√© {response.value:.1f} kWh avant-hier."
            elif validated_period == '7d' and ('semaine derni√®re' in question.lower() or 'derni√®re semaine' in question.lower()):
                response.answer = f"‚ö° Vous avez consomm√© {response.value:.1f} kWh la semaine derni√®re."
            else:
                response.answer = f"‚ö° Vous avez consomm√© {response.value:.1f} kWh sur la p√©riode demand√©e."
        else:
            # Fallback: formatage intelligent selon la question
            question_lower = question.lower()
            
            if 'hier' in question_lower:
                response.answer = f"‚ö° Vous avez consomm√© {response.value:.1f} kWh hier."
            elif 'avant-hier' in question_lower or 'avant hier' in question_lower:
                response.answer = f"‚ö° Vous avez consomm√© {response.value:.1f} kWh avant-hier."
            elif 'mois dernier' in question_lower:
                response.answer = f"üìÖ Vous avez consomm√© {response.value:.1f} kWh le mois dernier."
            elif 'mois' in question_lower:
                response.answer = f"üìÖ Vous avez consomm√© {response.value:.1f} kWh ce mois-ci."
            elif 'heure' in question_lower:
                response.answer = f"‚è∞ Votre consommation par heure est de {response.value/24:.2f} kWh en moyenne."
            elif 'augment√©' in question_lower:
                # Pour les questions d'√©volution, on pourrait ajouter une logique de comparaison
                response.answer = f"üìà Votre consommation actuelle est de {response.value:.1f} kWh."
            elif 'weekend' in question_lower:
                response.answer = f"üèñÔ∏è Analyse weekend/semaine: {response.value:.1f} kWh total."
            else:
                response.answer = f"‚ö° Vous avez consomm√© {response.value:.1f} kWh sur la p√©riode demand√©e."
        
        # üåü Ajouter de l'empathie et de la chaleur
        response.answer = self._add_warmth_and_empathy(response.answer, question)
        return response
    
    def build_granularity_response(self, question: str, mcp_result: Dict[str, Any], semantic_validation: Dict[str, Any] = None) -> StandardResponse:
        """üÜï Construit une r√©ponse de granularit√© (par heure, par jour, etc.)"""
        response = StandardResponse.from_mcp_result(question, mcp_result, ResponseType.CONSUMPTION)
        
        # Extraire la granularit√© de la validation s√©mantique
        granularity = None
        if semantic_validation and semantic_validation.get('validated_period'):
            granularity = semantic_validation['validated_period']
        
        # Ou de l'ex√©cution MCP
        if not granularity and mcp_result.get('data', {}).get('granularity'):
            granularity = mcp_result['data']['granularity']
        
        # Formatage selon la granularit√©
        granularity_formats = {
            'hourly': f"‚è∞ Votre consommation moyenne par heure est de {response.value:.2f} kWh/h.",
            'daily': f"üìÖ Votre consommation moyenne par jour est de {response.value:.1f} kWh/jour.",
            'weekly': f"üìä Votre consommation moyenne par semaine est de {response.value:.1f} kWh/semaine.",
            'monthly': f"üìà Votre consommation moyenne par mois est de {response.value:.1f} kWh/mois.",
            'yearly': f"üìä Votre consommation moyenne par an est de {response.value:.0f} kWh/an."
        }
        
        response.answer = granularity_formats.get(granularity, f"üìä Votre consommation moyenne est de {response.value:.2f} kWh par unit√© de temps.")
        
        # üåü Ajouter de l'empathie et de la chaleur
        response.answer = self._add_warmth_and_empathy(response.answer, question)
        return response
    
    def build_comparison_response(self, question: str, mcp_result: Dict[str, Any]) -> StandardResponse:
        """üÜï Construit une r√©ponse de comparaison intelligente"""
        response = StandardResponse.from_mcp_result(question, mcp_result, ResponseType.CONSUMPTION)
        
        # Formatage intelligent selon le type de comparaison
        question_lower = question.lower()
        
        if '√©t√©' in question_lower and 'hiver' in question_lower:
            response.answer = f"üåû‚ùÑÔ∏è Comparaison saisonni√®re: Les donn√©es montrent une consommation de {response.value:.1f} kWh. Une analyse plus d√©taill√©e n√©cessiterait des donn√©es saisonni√®res sp√©cifiques."
        elif 'dernier' in question_lower or 'pr√©c√©dent' in question_lower:
            response.answer = f"üìà Comparaison temporelle: Votre consommation actuelle est de {response.value:.1f} kWh. L'√©volution par rapport √† la p√©riode pr√©c√©dente n√©cessite une analyse comparative."
        elif 'weekend' in question_lower and 'semaine' in question_lower:
            response.answer = f"üèñÔ∏è Comparaison weekend/semaine: Analyse des habitudes de consommation - {response.value:.1f} kWh total observ√©."
        elif 'ann√©e' in question_lower or 'annuel' in question_lower:
            response.answer = f"üìÖ Consommation annuelle: {response.value:.1f} kWh sur la p√©riode analys√©e."
        else:
            response.answer = f"üìä Analyse comparative: {response.value:.1f} kWh observ√© pour la comparaison demand√©e."
        
        # üåü Ajouter de l'empathie et de la chaleur
        response.answer = self._add_warmth_and_empathy(response.answer, question)
        return response
